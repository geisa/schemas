syntax = "proto3";

message PlatformDiscovery_GEISA {
	int32 ver_major = 1;
	int32 ver_minor = 2;
	int32 ver_rev = 3;
	bool pillar_adm = 10;
	bool pillar_api = 11;
	bool pillar_lee = 12;
	bool pillar_vee = 13;
}

enum PlatformDiscovery_Type {
	DEVICE_TYPE_UNSPECIFIED = 0;

	DEVICE_TYPE_ELECTRIC_METER = 100;

	DEVICE_TYPE_METROLOGY_PROCESSOR = 200;
	DEVICE_TYPE_COMPUTE_CARD = 201;
	DEVICE_TYPE_NETWORK_CARD = 202;
	DEVICE_TYPE_COPROCESSOR_CARD = 203;
}

message PlatformDiscovery_Module {
	PlatformDiscovery_Type type = 1;
	string manufacturer = 2;
	string model = 3;
	string serial_number = 4;
	string hw_revision = 5;
	string fw_revision = 6;
}

message PlatformDiscovery_Device {
	PlatformDiscovery_Module top_module = 1;
	repeated PlatformDiscovery_Module sub_module = 2;
}

message PlatformDiscovery_Operator {
	/* TBD */
}

message PlatformDiscovery_Metrology {
	/* TBD */
}

message PlatformDiscovery_Sensor {
	/* TBD */
}

message PlatformDiscovery_Network {
	/* TBD */
}

enum Waveform_Datatype {
	DATA_INT16 = 0;
	DATA_INT32 = 1;
	DATA_FLOAT32 = 2;
	DATA_FLOAT64 = 3;
}

message PlatformDiscovery_Waveform_Instance {
	// platforms may provide multiple instances of a waveform with different attributes.
	// the application may subscribe to any or multiple of these by instance id.
	int32 instance_id = 1;

	string data_connection = 100;	// path to AF_UNIX socket

	Waveform_Datatype datatype = 200;
	// when datatype is int16 or int32, these multiplers can be applied by the application
	// to convert from those unitless values into "volts" or "amps" respectivly.
	double voltage_multiplier = 201;
	double current_multiplier = 202;

	float num_voltage_ch = 300;
	float num_current_ch = 301;
	float num_other_ch = 302;

	// if true, the sampling rate is locked to and tracks a multiple of the AC frequency
	// if false, the sampling rate matches the CPU clock and may drift vs the AC frequency
	bool sample_rate_is_cycle_locked = 400;
	// in hz
	int32 sample_rate = 401;

	// if true, each frame starts (and ends) at a zero crossing of the 'A' voltage
	bool frame_is_cycle_aligned = 402;

	// the expected duration of each data frame in samples
	int32 frame_duration_samples = 403;

	// if a hardware or software filter is applied to the signal prior to delivery
	// these are the frequency (in hz) of those filters.  if both low and high are
	// provided, a bandpass filter is implied.
	int32 voltage_filter_lowpass = 500;		
	int32 voltage_filter_highpass = 501;
	int32 current_filter_lowpass = 502;
	int32 current_filter_highpass = 503;
}

message PlatformDiscovery_Waveform {
	repeated PlatformDiscovery_Waveform_Instance instances = 1;
}


// This is the most outer message for Platform Discovery Request
// Message topic: geisa/api/platform-discovery-req
message PlatformDiscovery_Req {
}

// This is the most outer message for Platform Discovery Response
// Message topic: geisa/api/platform-discovery-rsp
message PlatformDiscovery_Rsp {
	PlatformDiscovery_GEISA geisa = 1;
	PlatformDiscovery_Device device = 2;
	PlatformDiscovery_Operator operator = 3;
	PlatformDiscovery_Metrology metrology = 4;
	PlatformDiscovery_Sensor sensor = 5;
	PlatformDiscovery_Network network = 6;
	PlatformDiscovery_Waveform waveform = 7;
}


// This is the most outer message for Application Manifest Request
// Message topic: geisa/api/app-manifest-req/<userid>
message ApplicationManifest_Req {
}

// This is the most outer message for Application Manifest Response
// Message topic: geisa/api/app-manifest-rsp/<userid>
message ApplicationManifest_Rsp {
	bytes manifest = 1; // TBD: spec shows this as json?
}



